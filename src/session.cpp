#include "session.h"
#include <QDebug>

Session::Session(int length, double coherenceScore, double achievementScore, int challengeLevel, int bpInterval, bool isHRContact) {
    this->length = length;
    this->coherenceScore = coherenceScore;
    this->achievementScore = achievementScore;
    this->challengeLevel = challengeLevel;
    this->bpInterval = bpInterval;
    this->isHRContact = isHRContact;
    this->coherenceLevel = 0;
    this->lowCount = 0;
    this->mediumCount = 0;
    this->highCount = 0;
    this->lowPercentage = 0.0;
    this->mediumPercentage = 0.0;
    this->hjghPercentage = 0.0;

    // create the timer and connect it to the updateCoherenceScore slot
    this->timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(beep()));
    timer->start(1000); //Start the timer for 1 second interval

    // initialize the HRV graph with empty data
    this->hrvData = new QVector<QPointF>();
}

Session::~Session() {
    delete this->timer;
    delete this->hrvData;
}

QTimer* Session::getTimer() {
    return this->timer;
}

double Session::getLength() {
    return this->length;
}

void Session::setLength(double len) {
    this->length = lenth;
}

double Session::getCoherenceScore() {
    return this->coherenceScore;
}

double Session::getAchievementScore() {
    return this->achievementScore;
}

//int Session::getChallengeLevel() {
//    return this->challengeLevel;
//}

int Session::getBPInterval() {
    return this->bpInterval;
}

bool Session::isHRContactOn() {
    return this->isHRContact;
}

// ?????????
QString Session::getCoherenceLevel() {
    if (coherenceLevel < 1) {
        return "Low";
    } else if (coherenceLevel >= 1 && coherenceLevel < 2) {
        return "Medium";
    } else {
        return "High";
    }
}

void Session::updateCoherenceLevel(QString level) {
    if (level == "Low") {
        coherenceLevel = 0;
    } else if (level == "Medium") {
        coherenceLevel = 1;
    } else {
        coherenceLevel = 2;
    }
}

void Session::updateCoherenceScore(double newCoherenceScore) {
    this->coherenceScore = newCoherenceScore;
    if (newCoherenceScore < 1) {
        lowCount++;
    } else if (newCoherenceScore >= 1 && newCoherenceScore < 2) {
        mediumCount++;
    } else {
        highCount++;
    }
    updateAchievementScore(newCoherenceSocre);
}

void Session::calCLPercentage() {
    int totalCount = lowCount + mediumCount + highCount;
    if (totalCount != 0) {
        lowPercentage = lowCount / (double)totalCount;
        mediumPercentage = mediumCount / (double)totalCount;
        highPercentage = highCount / (double)totalCount;
}

double Session::getLowPercentage() {
    return lowPercentage;
}

double Session::getmediumPercentage() {
    return mediumPercentage;
}

double Session::getHighPercentage() {
    return highPercentage;
}
void Session::updateAchievementScore(double value) {
    achievementScore += value;
}

void Session::setHRContact(bool value) {
    isHRContact = value;
}

void Session::beep() {
    // TODO: implement the beep sound
    qDebug() << "beep";
}

void Session::updateHRVGraph() {
    // Update the HRV graph
}

// This function generates random heartbeat intervals as the original data for the program
// There are 3 phases of generation, and the interval generated by this function
// will be closer and closer to each other
// @param:
// timeLimit: the output data total time limit
QVector<double>* Session::simulateHeartIntervals(double timeLimit) {
    QVector<double>* heartIntervals = new QVector<double>();
    srand(time(NULL));
    double curTotal = 0;
    double randomNum = 0;
    while (curTotal < timeLimit) {

        if (curTotal < timeLimit/3) {
            randomNum = generateRandomDouble(0.6,1);
            heartIntervals->push_back(randomNum);
        }
        else if (curTotal >= timeLimit/3 && curTotal < timeLimit * 2 / 3) {
            randomNum = generateRandomDouble(0.7,0.9);
            heartIntervals->push_back(randomNum);
        }
        else {
            randomNum = generateRandomDouble(0.75,0.85);
            heartIntervals->push_back(randomNum);
        }
        curTotal += randomNum;
    }
    return heartIntervals;
}

// This is used for generate random double for the simulateHeartIntervals(int size) function
double Session::generateRandomDouble(double min, double max) {
    double temp = (double)rand() / RAND_MAX;
    return min + temp * (max - min);
}
