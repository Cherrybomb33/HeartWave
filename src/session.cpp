#include "session.h"
#include <QDebug>

Session::Session(int length, double coherenceScore, double achievementScore, int challengeLevel, int bpInterval, bool isHRContact) {
    this->length = length;
    this->coherenceScore = coherenceScore;
    this->achievementScore = achievementScore;
    this->challengeLevel = challengeLevel;
    this->bpInterval = bpInterval;
    this->isHRContact = isHRContact;
    this->coherenceLevel = "Low";
    
    // create the timer and connect it to the updateCoherenceScore slot
    this->timer = new QTimer(this);
    connect(timer, SIGNAL(timeout()), this, SLOT(updateCoherenceScore()));

    // initialize the HRV graph with empty data
    for (int i = 0; i < 64; i++) {
        this->hrvData.push_back(0);
    }
}

Session::~Session() {
    delete this->timer;
}

int Session::getTime() {
    return this->time.elapsed();
}

QTimer* Session::getTimer() {
    return this->timer;
}

double Session::getCoherenceScore() {
    return this->coherenceScore;
}

double Session::getAchievementScore() {
    return this->achievementScore;
}

int Session::getChallengeLevel() {
    return this->challengeLevel;
}

int Session::getBPInterval() {
    return this->bpInterval;
}

bool Session::isHRContactOn() {
    return this->isHRContact;
}

QString Session::getCoherenceLevel() {
    return this->coherenceLevel;
}

void Session::updateCoherenceScore() {
    // get the last 64 HRV data points
    vector<double> hrvData = this->hrvData.mid(this->hrvData.size() - 64, 64);

    // calculate the coherence score
    double newCoherenceScore = this->calculator(&hrvData);

    // update the coherence score
    this->updateCoherenceScore(newCoherenceScore);

    // update the HRV graph
    this->updateHRVGraph();

    // check if the coherence level has changed
    QString newCoherenceLevel = this->getCoherenceLevel();
    if (newCoherenceLevel != this->coherenceLevel) {
        // update the coherence level
        this->updateCoherenceLevel(newCoherenceLevel);

        // make a beep sound
        this->beep();
    }
}

void Session::updateCoherenceScore(double newCoherenceScore) {
    this->coherenceScore = newCoherenceScore;
    this->achievementScore += newCoherenceScore;
}

void Session::updateAchievementScore(double value) {
    achievementScore += value;
}

void Session::setHRContact(bool value) {
    isHRContact = value;
}

void Session::updateCoherenceLevel(QString level) {
    coherenceLevel = level;
}

double Session::calculator(vector<double>* intervals) {
    
}

void Session::beep() {
    // TODO: implement the beep sound
    qDebug() << "beep";
}

void Session::updateHRVGraph() {
    // Update the HRV graph
}

// This function generates random heartbeat intervals as the original data for the program
// There are 3 phases of generation, and the interval generated by this function
// will be closer and closer to each other
// @param:
// size: the output data size
vector<double>* Session::simulateHeartIntervals(int size) {
    vector<double>* heartIntervals = new vector<double>();
    srand(time(NULL));
    for (int i = 0; i < size; i++) {
        if (i < size/3) {
            heartIntervals->push_back(generateRandomDouble(0.6,1));
        }
        else if (i >= size/3 && i < size * 2 / 3) {
            heartIntervals->push_back(generateRandomDouble(0.7,0.9));
        }
        else {
            heartIntervals->push_back(generateRandomDouble(0.75,0.85));
        } 
    }
    return heartIntervals;
}

// This is used for generate random double for the simulateHeartIntervals(int size) function
double Session::generateRandomDouble(double min, double max) {
    double temp = (double)rand() / RAND_MAX;
    return min + temp * (max - min);
}